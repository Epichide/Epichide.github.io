{"meta":{"title":"Epic","subtitle":"","description":"","author":"Epichide","url":"https://epichide.github.io","root":"/"},"pages":[{"title":"","date":"2024-08-11T07:12:08.179Z","updated":"2024-08-11T07:12:08.179Z","comments":false,"path":"categories/index.html","permalink":"https://epichide.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2024-08-11T07:11:45.542Z","updated":"2024-08-11T07:11:45.542Z","comments":false,"path":"tags/index.html","permalink":"https://epichide.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"chan vess segmentation","slug":"Chan–Vese-Segmentation","date":"2024-06-10T08:35:20.000Z","updated":"2024-08-11T07:17:08.484Z","comments":true,"path":"2024/06/10/Chan–Vese-Segmentation/","permalink":"https://epichide.github.io/2024/06/10/Chan%E2%80%93Vese-Segmentation/","excerpt":"chan vess segmentation","text":"chan vess segmentation sign illustration f : denote the given grayscale image, f(x),x is point t : iteration t's border matrix, binary bool ?, describe as iteration th 's edge result, is closed curve mask ε : Heaviside regularization,custom params, = 1 x : pixel/position in image,2D φ : level set function, φ(i,j),φi,j : φ value at point(i,j) C : an edge set curve image Boundary C represented as the zero level set of implicit function φ(x, y)1 H : Heaviside function, for caculate energy function Hε(t,p) : regularised heavyside function, is matrix , size same to image,∈[0,1] for example: if border mark 1, unkown area mark 0, that trans to 1 and 0.5 operator illustration: : sum for all H matrix value —— np.sum(H), is a scale value cinner couter : the optimal values c1 and c2 u : piecewise-smooth function The third and fourth terms penalize discrepancy between the piecewise constant model u and the input image f. divergence 散度计算: 12345def div(fx,fy):# 图像的散度对某幅图像连续求2次梯度得到的zx_x和zy_y的和是等于散度的。换句话说div(z) = zx_x +zy_yd Fyy,fyx=np.grad(fy) Fxy,fxx=np.grad(fx) return fxx+fyy discretize the curvature 曲率计算 : 1234567 def curvature(f): fy,fx=grad(f) Norm=np.sqrt(fx**2+fy**2) Nx=fx/(Norm+1e-8) Ny=fy/(Norm+1e-8) return div(Nx,Ny) img ∇x+ denotes forward diﬀerence in the x dimension : f(x+1)-f(x) ∇x− denotes backward diﬀerence : f(x)-f(x-1) ∇x0 =(∇x+ + ∇x−)/2 is central diﬀerence : (f(x+1)-f(x-1))/2 process step φ update function: φ value at point(i,j) φi,j length penalty μ =0.2, area penalty ν = 0, time step dt = 0.5, convergence tolerance tol = 10e−3 algorithm image-20220411145745250 Reference Deep Learning of Unified Region, Edge, and Contour Models for Automated Image Segmentation↩︎","categories":[{"name":"imageProcess","slug":"imageProcess","permalink":"https://epichide.github.io/categories/imageProcess/"}],"tags":[{"name":"levelset","slug":"levelset","permalink":"https://epichide.github.io/tags/levelset/"},{"name":"segmentation","slug":"segmentation","permalink":"https://epichide.github.io/tags/segmentation/"},{"name":"algotithm","slug":"algotithm","permalink":"https://epichide.github.io/tags/algotithm/"}]},{"title":"Hexo 富文本","slug":"use-note-block","date":"2024-06-10T08:35:20.000Z","updated":"2024-08-11T16:52:24.583Z","comments":true,"path":"2024/06/10/use-note-block/","permalink":"https://epichide.github.io/2024/06/10/use-note-block/","excerpt":"","text":"在 Hexo 中使用 NOTE 提示块 123456789101112131415161718192021222324&#123;% note default %&#125;一个 default 提示&#123;% endnote %&#125;&#123;% note primary %&#125;一个 primary 提示&#123;% endnote %&#125;&#123;% note success %&#125;一个 success 提示&#123;% endnote %&#125;&#123;% note info %&#125;一个 info 提示&#123;% endnote %&#125;&#123;% note warning %&#125;一个 warning 提示&#123;% endnote %&#125;&#123;% note danger %&#125;一个 danger 提示&#123;% endnote %&#125; 一个 default 提示 一个 primary 提示 一个 success 提示 一个 info 提示 一个 warning 提示 一个 danger 提示 使用 Tabs 标签 123456789101112&#123;% tabs 标签, 1 %&#125; &lt;!-- tab --&gt;**选项卡 1** &lt;!-- endtab --&gt;&lt;!-- tab --&gt;**选项卡 2**&lt;!-- endtab --&gt;&lt;!-- tab 标签三 --&gt;**选项卡 3** , 名字为 `TAB三`&lt;!-- endtab --&gt;&#123;% endtabs %&#125; 标签 1标签 2标签三选项卡 1选项卡 2选项卡 3 , 名字为 TAB三","categories":[{"name":"web","slug":"web","permalink":"https://epichide.github.io/categories/web/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://epichide.github.io/tags/hexo/"},{"name":"markdown","slug":"markdown","permalink":"https://epichide.github.io/tags/markdown/"}]},{"title":"HEXO typora github blog 博客搭建","slug":"blog-github","date":"2024-06-10T08:35:20.000Z","updated":"2024-08-11T13:40:22.972Z","comments":true,"path":"2024/06/10/blog-github/","permalink":"https://epichide.github.io/2024/06/10/blog-github/","excerpt":"介绍hexo 的基本生成部署操作和typora的文件如何更新到博客","text":"介绍hexo 的基本生成部署操作和typora的文件如何更新到博客 Hexo 基本操作 我们定义根目录是含有主题、 source等信息的根目录，如下是根目录内的文件 image-20240811020929586 首先是要先把新建的仓库clone到本地，新建博客源码分支，初始化hexo，具体命令如下： 12345678910111213141516$ git clone xxxxxx // xxxxx是github上复制的clone地址$ cd xxxxxx // clone到本地会生成一个跟仓库同名的目录$ git checkout -b hexo // 创建并切换到hexo分支$ hexo init hexo // 初始化hexo，第一个hexo是cmd，第二个hexo是新建hexo目录$ cd hexo // 进入新建的hexo目录$ npm install // 安装相关依赖$ hexo g // generate，生成静态网站$ hexo s // server，本地预览12345678910111213141516 到这里就可以打开浏览器输入localhost:4000，进行本地预览了。 站点文件配置 还需要修改Hexo的配置文件_config.yml，注意此文件应位于hexo目录下，称为站点配置文件。在themes/主题名路径下也有一个_config.yml，称之为主题配置文件。在站点配置文件同级目录下，你可以添加多个主题 添加主题 比如添加next主题： 1234$ cd hexo //确保当前目录处于站点配置目录下// clone NexT主题，如果使用https clone报错，可以自行替换为ssh的链接$ git clone https://github.com/theme-next/hexo-theme-next themes/next 执行如下命令本地验证主题是否生效： 1234$ hexo clean // 清理之前生成的资源$ hexo g // 重新生成$ hexo s // 启动本地服务123 打开浏览器输入localhost:4000，进行本地预览。 image-20240811021553913 部署deploy到github 首先需要安装插件hexo-deployer-git 12$ npm install hexo-deployer-git --save 修改站点配置文件，搜索deploy 123456789101112# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: git repo: # 需要替换为自己仓库的链接，根据https或ssh方式不同自由选择，我已经上传了公钥，所以选择ssh # 如果你配置了多用户ssh，可考虑更改 github.com 为你设置的histname， # 比如 github: git@github_aaa:treeknows/treeknows.github.io.git github: git@github.com:treeknows/treeknows.github.io.git # 此处似乎只能选择master，配置为main时，实际还是会部署到master分支 branch: master123456789 可以将配置修改为如上，记得替换自己的仓库链接。此外配置branch时，设置为main实测是无效的，依旧会push到master分支，如果没有master分支，则会自己创建。这也是为什么在前面推荐修改默认创建分支为master，来自强迫症患者的倔强。 多个GitHub账号配置和多个Hexo博客地址配置 如果你使用 多个GitHub账号配置和多个Hexo博客地址配置， 则需要做一些操作 删除全局配置 123git config --global --unset 'user.name'git config --global --unset 'user.email' 设置local配置 在自己的每个文件夹(repo仓库)下,打开Git Bash,然后进行设置。 12git config user.name `xxx`git config user.email `xxx@xxx.com` 部署到Github 修改配置后，需要手动部署到Github 1hexo g -d 部署成功后，稍待片刻，便可访问GitHub上自己的博客查看效果了。 问题 问题1： You have to configure the deployment settings in _config.yml first! image-20240811023454559 原因：yml格式不对 冒号后面唯一空格，是repo 不是github image-20240811023624065 问题2 fatal: unable to auto-detect email address https://blog.csdn.net/nineya_com/article/details/103301870 在这里插入图片描述 2.进入我们博客目录的“.deploy_git.git”子目录，找到config文件。 3.打开config文件，添加以下内容 1234[user] email=你的邮箱 name=GitHub用户名 再次运行 1hexo g -d 问题3：blog 404 github创建个人网页登录后404无法显示的问题 https://blog.csdn.net/weixin_43658047/article/details/133742886 image-20240811031004276 1.首先必须要有内容，默认是会找index.html文件，找不到该文件会找readme.md文件，也就是说最简单的方法是，创建了与用户名同名的repository后username.github.io后，添加一个readme.md文件，得在readme里打点字，这个里面得有东西 2.另外在username.github.io这个repository的setting/github page中这个选择Deploy from a branch，注意将仓库里里的main分支改为master，同时在下图页面，将底下默认的main改成master，就能访问了 image-20240811031048976 typora更新至blog generate md 和image存放结构 在 讨论图片如何设置前，我们需要先知道 hexo g 的时候图片和md文件会如何放置 在_config.yml文件里有一个参数 post_asset_folder , 它有两个作用： 如果为true， 会在使用 hexe new blogname 时候，在创建 md文件同时 ，还创建一个同名文件夹 123_posts [blogname.md] [blogname] 同时还需要安装一个插件 hexo-asset-image 1npm install https://github.com/CodeFalling/hexo-asset-image --save 即post_asset_folder 激活 和 hexo-asset-image 插件安装好情况下，在generate的时候， 除了 在imgs在存放 img ，还在 blog里存放img image-20240811123640730 如果为false，只在source/imgs在存放 img image-20240811123744791 总结路径关系： source/posts里 的 md → public/yy/mm/dd/blogname/index.html source/imgs/blogname里 的 image → public/imgs/blogname/image source/posts/blogname里 的 image → public/yy/mm/dd/blogname/images(只在post_asset_folder 为true + 安装hexo-asset-image时 产生 ) image-20240811051938209 typora图片路径 根据是否激活post_asset_folder，其路径配置也不太一样， 目前 只有激活的的没有问题，没有激活的html的图片显示还是有些问题没有解决 post_asset_folder 为 true 我们先观察blog取的图片路径，以next主题为例（其他主题可能有差异，不能确定是否适用），需要显示图片的主要有两个地方：1. home 预览页即主页 2. 完整博客内容页 切换 post_asset_folder 后，注意要使用hexo clean 一下 post_asset_folder 为 true+ 安装hexo-asset-image，预览和博客的图片根路径都是 public/yy/mm/dd： image-20240811130130376 post_asset_folder 为 false+ 安装hexo-asset-image，预览的路径public 博客路径public/yy/mm/dd/blogname ，使用的路径是不同的，因而需要存放多次，可能存在预览和博客内容不一致的情况： image-20240811130511497 那么在上传新的博客的时候，只要在_posts 存放 md 文件和同名文件即可，md 按照blogname/image的形式获取即可 123_posts [blogname.md] [blogname] typora 图片拷贝文件位置就可以这样设置./$(filename) image-20240811132309452 post_asset_folder 为 false 没整明白。。。。。。 对于hexo 图片的路径和博客是分开的，图片从根目录开始为 imgs/标题名/xxxpng ，比如下面这个是一个能够正常获取的图片路径 imgs\\blogname\\xxx.png image-20240811052444531 因此typora的图片插入路径需要与之保持统一，即路径名一致 imgs\\blogname\\xxx.png typora img path 我们只要确保md能够通过这一路径访问并显示图片，那么我们就能实现typora和网页端都能正常显示图片了，typora 显示这种路径规则的图片有多种方式： 最简单的，把图像存在imgs中 在preference中设置图片的copy路径 ，imgs/$filename 在md 文件中 用 imgs\\blogname\\xxx.png 获取图片 多种组合实现：举个例子： 在preference中设置图片的copy路径 ，比如 ../imgs/$filename 在format - image - use image root path 设置 .. 上一级目录为图片根目录 image-20240811055105205 在md 文件中 用 imgs\\blogname\\xxx.png 获取图片 1+2部其实就消除了 .. md文件 head 12345678---title: 测试文章date: 2021-06-10 16:35:20tags:- 原创categories:- Java--- 将&lt;!-- more --&gt;插入到文章后，主页在插入处截止了预览，出现的阅读全文的按钮。 问题： 路径错误/.com// hexo图片显示不出且图片路径错误/.com// https://blog.csdn.net/sluck_0430/article/details/136431303 卸载 hexo-asset-image 插件：npm uninstall hexo-asset-image 即可 公式渲染 首先，在NexT主题配置文件中将mathjax设为渲染引擎 1234math: ... mathjax: enable: true mathjax 和 katex 是互斥的两个选项，enable 不能同时 true或 false。 如果设置 mathjax : true ，就需要更换渲染引擎， hexo-renderer-pandoc 或 hexo-renderer-kramed。 如果 katex : true ，则需要更换 hexo-renderer-markdown-it ，或者在原来的 hexo-renderer-marked 引擎下使用 markdown-it-katex plugin。 安装插件 12npm uninstall hexo-renderer-marked --savenpm npm install hexo-renderer-pandoc --save md head添加mathjax 123title: xxx......mathjax: true 重新生成和启动本地服务器 hexo clean &amp;&amp; hexo s 就可以显示公式了，像这样 主题 ==TODO== REFERENCE REF： Github Pages + Hexo框架 + NexT主题搭建个人博客：https://blog.csdn.net/Darlinnn/article/details/130279000 Git 多个GitHub账号配置和多个Hexo博客地址配置：https://blog.csdn.net/Tmraz/article/details/107400453#5__55 GitHub Pages + Hexo搭建个人博客网站，史上最全教程：https://blog.csdn.net/yaorongke/article/details/119089190 【Hexo】GitHub+Typora写博客+图片上传:https://blog.csdn.net/Qxiaofei_/article/details/124629908 Hexo Next主题渲染 Latex 公式的配置方法","categories":[{"name":"web","slug":"web","permalink":"https://epichide.github.io/categories/web/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://epichide.github.io/tags/hexo/"},{"name":"github","slug":"github","permalink":"https://epichide.github.io/tags/github/"},{"name":"typora","slug":"typora","permalink":"https://epichide.github.io/tags/typora/"}]},{"title":"配置 SSH 管理多个 Git 仓库和以及多个 Github 账号","slug":"ssh-github","date":"2024-06-10T08:35:20.000Z","updated":"2024-08-11T08:28:34.764Z","comments":true,"path":"2024/06/10/ssh-github/","permalink":"https://epichide.github.io/2024/06/10/ssh-github/","excerpt":"基本介绍 使用场景 假如你拥有多个github账户，那么在编辑和push 仓库的时候需要指定特定用户进行登录，对于github仓库管理是通过ssh与github进行通讯的，那么就需要管理不同的账户下的SSH配置，即SSH公钥和 私钥。","text":"基本介绍 使用场景 假如你拥有多个github账户，那么在编辑和push 仓库的时候需要指定特定用户进行登录，对于github仓库管理是通过ssh与github进行通讯的，那么就需要管理不同的账户下的SSH配置，即SSH公钥和 私钥。 SSH 如果我们要使用 Github 这种 git 代码托管平台的话，首先本地要生成一个 SSH 私钥(如id_rsa) 和 公钥(如id_rsa.pub)，然后将 公钥 填写到 Github 的 SSH Key 管理面板中。当我们向 Github 推送代码的时候会首先发起身份校验。此时，本地会将用户信息通过 SSH 私钥 执行『签名』操作 本地 - 私钥 - id_rsa github - 公钥 - id_rsa.pub 通过配置各个用户名的公钥和私钥，在使用的时候指定使用对应的私钥即可通过认证，进行通讯和数据传输。举例来说，如果我们要使用 Github 这种 git 代码托管平台的话，首先本地要生成一个 SSH 私钥(如id_rsa) 和 公钥(如id_rsa.pub)，然后将 公钥 填写到 Github 的 SSH Key 管理面板中。当我们向 Github 推送代码的时候会首先发起身份校验。此时，本地会将用户信息通过 SSH 私钥 执行『签名』操作。当签名信息发送到 Github 的时候，Github 就会使用用户保存在平台上的 公钥 来校验签名信息，使用 私钥 签名信息只能由对应的 公钥 进行校验，因此如果 Github 对签名校验通过，就可以认证当前的用户对代码仓库拥有响应的操作权限，之后就可以让用户提交的代码入库了，整体流程如下图： img 使用 SSH公钥/私钥生成 进入到 ssh 目录下，windows一般是：C:【用户名】\\.ssh 假设你的邮箱是 aaa@126.com 生成一对 SSH 密钥 1ssh-keygen -t rsa -C &quot;aaa@126.com&quot; 这个指令的意思是使用 ssh-keygen 生成密钥，-t 参数密钥的加密方式是 rsa，-C 参数可以为密钥指定备注，通常备注可以为你的邮箱，或者你也可以写成你要连接的远程服务器名（总之不重要） 输入完成之后会进入一个交互式终端界面，首先会询问你的密钥文件名称： 1Enter file in which to save the key (/Users/username/.ssh/id_rsa): 我们可以使用回车跳过，那么密钥文件名称就自动生成为 id_加密方式，如 id_rsa。 之后会提示用户输入密码： 1Enter passphrase (empty for no passphrase): 这个密码是用来保护你的私钥的，我们这里避免麻烦可以直接跳过。 完成以后，目录下会产生私钥文件 id_rsa 和公钥文件 id_rsa.pub . 如果你之前和其他网站也配置过 ssh 产生过这些文件，注意先备份一个，因为这个操作会覆盖原来的同名文件。 随后到github 上选择 setting → ssh and GPG keys → new ssh key image-20240811005017813 随后把公钥里的内容粘贴到 key里，title可随意命名 image-20240811005251367 config 文件配置ssh 一般来说如果没有其他指定的配置，在访问的时候会自动使用 id_rsa作为认证私钥，如果单一账户不需要配置，如果你配置了多个ssh，则需要通过config文件配置 假设 你在github 有两个账户 aaa，bbb 对应的私钥 id_rsa 重命名为 aaa_id_rsa 和 bbb_ id_rsa 账户1 ： aaa ， 对应私钥 ： 12345678910111213# github 主账号的配置Host github_aaa User git Hostname github.com PreferredAuthentications publickey IdentityFile ~/.ssh/aaa_id_rsa # github 新账号的配置Host github_bbb User git Hostname github.com PreferredAuthentications publickey IdentityFile ~/.ssh/bbb_ id_rsa 从上面配置文件可以看到 Host别目和公钥是二者的主要区别， user 设定为git是访问GitHub是需要使用的统一用户名，其实写不写都无所谓，ssh 连接主要是通过这里 hostname确定要用哪一个私钥进行认证 config 配置文件中的各项配置意思为： Host：指定连接到的主机名，可以随意指定，相当于实际连接目标主机的别名； User：指定使用的用户名，通常为 git，也可以不指定； Hostname：指定连接到的主机的实际域名或IP地址。如果是向 Github 推送代码，则为 github.com，如果是向公司的 Git 代码托管平台推送代码，则填写公司主机的地址 Port：SSH 服务的端口号，默认为 22，可以不写 PreferredAuthentications：指定优先使用的身份验证方法，指定为publickey，即使用公钥进行身份认证。 IdentityFile：指定要使用的私钥文件路径，即指向你创建的私钥，我们这里分别为不通的 Git 代码托管平台指定了不同的私钥 测试连接 然后我们来测试一下连接： 123ssh -T git@github_aaa# 输出如下内容就说明身份认证通过了！Hi aaa[你小号的用户名]! You&#x27;ve successfully authenticated, but GitHub does not provide shell access. 由于你的代码的仓库源在 Github 上，因此 SSH 连接的主机就是 github.com，github_aaa 对应的实际主机就是github.com， git是默认访问github的用户名， 由于在这里制定了use，因此配置文件里的usr并不起作用。 如果输出的用户名是你的小号，那就说明可以正常在刚才的那个仓库里推送代码了。 拉取仓库 这个时候，你从小号的 Github 中 clone 下来一个仓库，假设地址为 git@github.com:user_x/blog.git，那么就在终端中的host：github.com 改为 github_aaa： 123git clone git@github.com:user_x/blog.gitgit clone git@github_aaa:user_x/blog.git img 提交 #TODO REF： 如何配置 SSH 管理多个 Git 仓库和以及多个 Github 账号","categories":[{"name":"web","slug":"web","permalink":"https://epichide.github.io/categories/web/"}],"tags":[{"name":"github","slug":"github","permalink":"https://epichide.github.io/tags/github/"},{"name":"ssh","slug":"ssh","permalink":"https://epichide.github.io/tags/ssh/"}]}],"categories":[{"name":"imageProcess","slug":"imageProcess","permalink":"https://epichide.github.io/categories/imageProcess/"},{"name":"web","slug":"web","permalink":"https://epichide.github.io/categories/web/"}],"tags":[{"name":"levelset","slug":"levelset","permalink":"https://epichide.github.io/tags/levelset/"},{"name":"segmentation","slug":"segmentation","permalink":"https://epichide.github.io/tags/segmentation/"},{"name":"algotithm","slug":"algotithm","permalink":"https://epichide.github.io/tags/algotithm/"},{"name":"hexo","slug":"hexo","permalink":"https://epichide.github.io/tags/hexo/"},{"name":"markdown","slug":"markdown","permalink":"https://epichide.github.io/tags/markdown/"},{"name":"github","slug":"github","permalink":"https://epichide.github.io/tags/github/"},{"name":"typora","slug":"typora","permalink":"https://epichide.github.io/tags/typora/"},{"name":"ssh","slug":"ssh","permalink":"https://epichide.github.io/tags/ssh/"}]}