{"meta":{"title":"Epic","subtitle":"","description":"","author":"Epichide","url":"https://epichide.github.io","root":"/"},"pages":[{"title":"","date":"2024-08-11T07:11:45.542Z","updated":"2024-08-11T07:11:45.542Z","comments":false,"path":"tags/index.html","permalink":"https://epichide.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2024-08-11T07:12:08.179Z","updated":"2024-08-11T07:12:08.179Z","comments":false,"path":"categories/index.html","permalink":"https://epichide.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"my-first-job","slug":"firstjob","date":"2024-08-16T08:35:22.000Z","updated":"2024-08-16T13:26:54.310Z","comments":true,"path":"2024/08/16/firstjob/","permalink":"https://epichide.github.io/2024/08/16/firstjob/","excerpt":"","text":"第一份工作并不那么风光，也没有想象的钱多，每天做着琐碎的事情。常常是一边抱怨着工作，一边无奈自己的受限的能力。曾经的我励志要扭转自己的专业和航道，却在工作和年龄中逐渐消磨。 不愿如此，只做着打杂的事情，想学硬件，现在却越走越远，形同陌路。原来的我眼中闪光，计划未来，现在的我只像韩国电影《寄生虫》般，想着如果。 身旁活得比自己成功，天资聪颖的人，他们知道时间投在那些具有效益地方，而我却如此拧巴，没有更强的能力，却天天投在无用的幻想中，脚不踏实地。未来的自己去向何方，我真能对世界有更多的了解吗，还是这样浑浑噩噩，走向晚年。我好害怕最终活成那样。。。。。。","categories":[{"name":"though","slug":"though","permalink":"https://epichide.github.io/categories/though/"}],"tags":[]},{"title":"NIQE 自然图像质量评估器（Natural Image Quality Evaluator）","slug":"NIQE","date":"2024-08-14T08:35:20.000Z","updated":"2024-08-17T14:11:18.829Z","comments":true,"path":"2024/08/14/NIQE/","permalink":"https://epichide.github.io/2024/08/14/NIQE/","excerpt":"","text":"IQA model 分类 在图像质量评估(IQA)领域，OA、OU、DA和DU是描述评估模型特性的术语，它们分别代表： OA (Opinion-Aware): 意见感知型。这种类型的IQA模型在训练阶段使用了人类对失真图像的评分数据。换句话说，这些模型通过学习人类对图像质量的主观评价来预测图像质量。OA模型能够评估它们在训练数据中见过的失真类型。 DIVINE CBIQ LBIQ BLIINDS BRISQUE OU (Opinion-Unaware): 意见不感知型。与OA模型不同，OU模型在训练时不使用人类对失真图像的评分。它们不依赖于人类对特定失真类型的主观评价，而是通过其他方式来评估图像质量。 DA (Distortion-Aware): 失真感知型。DA模型在设计时考虑了特定的失真类型，它们通过训练来识别和评估这些特定的失真。这些模型对它们训练中包含的失真类型有更好的评估能力。 DU (Distortion-Unaware): 失真不感知型。DU模型在设计时不针对任何特定的失真类型。它们不使用关于失真的先验知识，而是依赖于自然图像的统计特性来评估图像质量。 SSIM 或许可以这么理解 opnion 类似于mos打分数据集, distortion类似于某些图像问题数据集,比如flick 、 contour 、purple firing 等. aware 表示需要相关数据库获取某些统计信息,给模型提供预先的参数,而 unaware 表示在没有相关数据集训练的情况下,也能进行评估 NIQE是a kind NSS-driven blind OU-DU IQA model,尽管NIQE也是用了BEISQUE的features BRISQUE 需要在提取特征后接一个 natural 和distored 图像的分类器,这个分类器是需要训练的. 因此BRISQUE属于 OA NIQE 虽然也用了BEISQUE的 mscn features, 在拟合MVG的时候貌似也用了自然数据获得的MVG 平均参数, 但一方面 MVG参数的获得可来源其他数据集,获得一个统计学知识,不需要再学习,一方面它没有对mos结果进行拟合,它知识统计了这些图像的某些特征均值.因此可以认为它是一个 OU的方法. 同理也是DU NIQE NIQE（Natural Image Quality Evaluator）是一种基于自然场景统计特征的无参考图像质量评估指标。其使用高斯混合模型（GMM）来建立自然图像特征的概率分布，并用该分布来评估输入图像的质量分数。 关于 NIQE的解释,这篇blog有不错的介绍,可以参阅: 无参考图像评价指标NIQE——自然图像质量 纹理区域 https://blog.csdn.net/weixin_45682889/article/details/108739906 文中提到,人们对于纹理处的模糊变化相较于平坦区域敏感. 因此需要筛选图像块. Since humans appear to more heavily weight their judgments of image quality from the sharp image regions. We use a simple device to preferentially select from amongst a collection of natural patches those that are richest in information and less likely to have been subjected to a limiting distortion. 筛选标准是：边缘更锐利的，包含信息内容更丰富的。 在归一化后，筛选前，作者将图像分成大小为PxP的若干个图像块（P=96），索引为b = 1,2,3,…,B 再对每个图像块求平均方差（也就是下文提到的锐利程度）： 如何筛选呢？ 作者将所有图像块的最大锐利程度的 p 倍设为阈值，其中p ∈ [0.6, 0.9]，论文中取值为 0.75。将大于阈值的图像块保留，小于阈值的图像块淘汰掉。 在这里插入图片描述 测试结果 感觉8*8 patch 上粗略分比较合适 patch : 16*16 image-20240817220720021 image-20240817220743568 image-20240817220900711 patch 8*8 image-20240817221049744 image-20240817221014791 image-20240817220932423 NIQE指标 无参考图像评价指标NIQE——自然图像质量 通过将自然图像块与MVG模型密度函数拟合，可以得到一个简单的NSS特征模型，MVG模型(Multivariate Gaussian Model)密度函数为： 式中( x 1 , . . , x k ) 是BRISQUE的NSS特征。v 与Σ 分别表示MVG模型的均值与协方差矩阵，可由标准最大似然估计得到,可通过统计自然图像得到,并存储下来 用NSS特征模型与提取自失真图像特征的MVG间的距离来表示失真图像的质量,即最后的NIQE指标： 其中v*1，v 2 ，Σ1，Σ2分别表示自然MVG模型与失真图像MVG模型的均值向量和协方差矩阵。 马氏距离 Mahalanobis distance 马氏距离详解（数学原理、适用场景、应用示例代码） 这里的NIQE指标 是统计学概念中的马氏距离 Mahalanobis distance 马氏距离实际上是欧氏距离在多变量下的“加强版”，用于测量点（向量）与分布之间的距离。 什么情况下适用马氏距离？ 当需要度量点（向量）与多变量分布之间的距离时，如果直接采用欧式距离，衡量的是两点之间的直接距离（点与分布之间的欧式距离，指的是向量x与变量空间中心的距离），而没有考虑数据的分布特性。 而采用马氏距离，在计算中对协方差进行归一化，则可以规避欧式距离对于数据特征方差不同的风险，从而使所谓的“距离”更加符合数据分布特征以及实际意义。1 如下图所示，这是是两个变量的简单散点图。左图是两个变量之间不相关，Point 1和Point 2与分布中心的距离相等。右图是两个变量之间呈正相关。即随着一个变量（x轴）的值增加，另一变量（y轴）的值也增加。 从几何上说，Point 1和Point 2两个点与分布中心的距离相等（欧几里得距离）。但是，即两点到分布的欧几里得距离相等，但实际上只有Point 1（蓝色）更容易采样获得,而point2 的概率很低。 这是因为，欧几里得距离仅是两点之间的距离，它不考虑数据集中的其余点的分布情况。因此，它不能用来真正判断一个点实际上与点的分布有多接近。所以我们需要的是更健壮的距离度量标准，该度量标准可以精确地表示一个点与分布之间的距离。 计算公式 向量x到一个均值为μ ，协方差为S 的样本分布的马氏距离计算如下： 直观解释 ( x − μ )本质上是向量与平均值的距离。然后，将其除以协方差矩阵（或乘以协方差矩阵的逆数）。 这实际上是多元变量的常规标准化（z =（x – mu）/ sigma）。也就是说，z =（x向量）–（平均向量）/（协方差矩阵）。 如果数据集中的变量高度相关，则协方差将很高。除以较大的协方差将有效缩短距离。 同样，如果X不相关，则协方差也不高，距离也不会减少太多。 因此，它有效地解决了规模问题以及前文中谈到的变量之间的相关性。 如果协方差矩阵为单位矩阵，即样本向量之间独立同分布，就得到欧式距离： 总结 brisque 和niqe brisque 和niqe 来自同个作者,整体的特征提取几乎是一样,主要在后面的处理: image-20240817213041123","categories":[{"name":"imageprocess","slug":"imageprocess","permalink":"https://epichide.github.io/categories/imageprocess/"}],"tags":[{"name":"IQA","slug":"IQA","permalink":"https://epichide.github.io/tags/IQA/"}]},{"title":"BRISQUE 无参考图像空间质量评估器（Blind/Referenceless Image Spatial Quality Evaluator)","slug":"BRISQUE","date":"2024-08-11T08:35:20.000Z","updated":"2024-08-17T13:23:53.234Z","comments":true,"path":"2024/08/11/BRISQUE/","permalink":"https://epichide.github.io/2024/08/11/BRISQUE/","excerpt":"","text":"BRISQUE 原理 朴素原理：自然无损的图像之间他们的某些统计属性更接近，而非寻常的人工图像（或是内容非自然或者自然图像经过失真处理）则不符合经验分布，比如下面两个图，左侧的图像亮度符合高斯，而人为的图像则不符合。于是有别于通过识别不同distortion类型判断失真程度，比如 blur、noise、compression ， 我们还可以通过与自然图像的总体统计值的偏差deviation 来评估感知质量。 Underlying Gaussianity of natural images BRISQUE则是属于后者的一类 通过分析NSS的无参图像评估 方法。 Natural Scene Statistics（NSS）本译作自然场景统计，但由于自然场景往往同时也是指观察或者拍摄到的图像，所以我们这里暂且称呼为自然图像统计。自然场景统计的规律性在视觉科学文献中已经很好的阐述，其中在空域和小波域中已经得到了证明。 自然图像有别于随机生成的噪声图像，失真的图像，以及很大一部分计算机图形学生成的图像等等，是指人眼或相机在自然界能够观察或拍摄到的清晰的图像[1]。自然图像实际上相对数量非常少，如果我们考虑给定大小的图像存在多少种可能性，仅仅是64x64大小（最大像素值255）的图像就有大约有 1010000 种可能性，其中包括绝大多数噪声图像，而自然图像只占据整个图像空间（image space）的极小一部分，因此被类比为“啤酒泡沫”[2]。自然图像就像啤酒泡沫一样，看似多种多样，其实只占所有图像中一小部分 输出特征 在BRISUQE模型中引入了一个基于 a new model of the statistics of pair-wise products of neighboring (locally normalized) luminance values. 的统计量，不仅进一步量化图像的自然度“naturalness”， 还能评估distortion quality 失真度 locally normalized luminance coefﬁcients in the spatial domain feat :MSCN fit :GGD parameter : α σ pairwise products of these coefﬁcients. along four orientations feat : MSCN*neighbor MSCN four orientations : horizontal (H ), H (i, j) = I(i, j)I(i, j + 1) vertical (V ), V (i, j) = Iˆ(i, j)Iˆ(i + 1, j) main-diagonal (D1) ,D1(i, j) = Iˆ(i, j)Iˆ(i + 1, j + 1) secondary-diagonal (D2),D2(i, j) = Iˆ(i, j)Iˆ(i + 1, j − 1) fit :AGGD parameter : v μ σl σr image-20240813012433491 因此总共输出 2+4*4=18 个参数,这些参数作为特征输出,进行以上步骤后再对原图像做0.5倍下采样，再提取一次特征，因此，共得到36个特征参数。 总体流程 image-20240816204626147 algorithm MSCN coefficient ： mean subtracted contract normalized coefficient 文章中的 就是 MSCN coefficient 。（i，j）为 （y，x），其计算公式为： 均值 计算,使用高斯滤波计算,wendow size=7,也就是K = L = 3 然后在均值的基础上计算标准差 standard deviation, 这里的标准差也通过高斯滤波得到君主标准差 python code 123456789101112131415161718192021def cal_mscn(grayimg): im_original=grayimg.copy() im = im_original.copy() # normalize the image im = im / 255.0 # calculating MSCN coefficients mu = cv2.GaussianBlur(im, (7, 7), 1.166) mu_sq = mu * mu sigma = cv2.GaussianBlur(im * im, (7, 7), 1.166) sigma = (sigma - mu_sq) ** 0.5 # structdis is the MSCN image structdis = im - mu structdis /= (sigma + 1.0 / 255) return structdisdef shift_mscn(img,shifty=0,shiftx=0): img=np.roll(img,shifty,axis=0) img=np.roll(img,shiftx,axis=0) return img example image-20240816205435767 MSCN distribution 对统计的fig2自然图像MSCN绘制直方图,像下面这样,mscn更接近一种高斯分布,后续可以用GGD进行拟合,对于 mscn相乘的结果，则用AGGD进行拟合 image-20240816205609727 GGD fit : generalized Gaussian distribution GGD function 从fig1中可以看到自然和非自然图像的MSCN分布是存在差异的,在beisqe算法中采用GGD来对该分布进行拟合 is the gamma function GGD parameters GGD共有两个参数 : α : 控制分布的形状 α=2 为零均值的高斯分布 α越小,越锋利,接近laplacian 分布 σ: 控制方差/标准差 相同方差不同形状参数的GGD 广义高斯分布(GGD)和非对称广义高斯分布(AGGD) generalized Gaussian distribution &amp; asymmetric generalized Gaussian distribution 广义高斯分布(generalized Gaussian distribution,GGD)和非对称广义高斯分布( asymmetric generalized Gaussian distribution,AGGD)被经常使用与图像/视频信号的统计分析，其形状参数常被用为图像的特征进行分类或回归。 GGD : α ,σ 广义高斯分布,在高斯分布基础上,增加了形状的调整参数 α,会影响峰度 is the gamma function AGGD : v, σl, σr 非对称广义高斯分布,在广义高斯分布基础上,增加了偏态调整参数 σl、σr, 分别控制左右两边的扩散程度 where 峰度kurtosis 和 偏度skewness 峰度 峰度 ≈ 0表示该总体数据分布与正态分布的陡缓程度相同； 峰度 &gt;0表示该总体数据分布与正态分布相比较为陡峭，为尖顶峰； 峰度 &lt;0表示该总体数据分布与正态分布相比较为平坦，为平顶峰。 峰度的绝对值数值越大表示其分布形态的陡缓程度与正态分布的差异程度越大。 img 偏度skewness 这个统计量同样需要与正态分布（也叫常态分布）相比较， 偏度 ≈ 0表示其数据分布形态与正态分布的偏斜程度相同； 偏度 &gt;0表示其数据分布形态与正态分布相比为正偏（右偏），即有一条长尾巴拖在右边，数据右端有较多的极端值，数据均值右侧的离散程度强； 偏度 &lt;0表示其数据分布形态与正态分布相比为负偏（左偏），即有一条长尾拖在左边，数据左端有较多的极端值，数据均值左侧的离散程度强 偏度的绝对值数值越大表示其分布形态的偏斜程度越大。 img example For example, blur creates a more Laplacian appearance, while white-noise distortion appears to reduce(原文是不是写错了) the weight of the tail of the histogram. image-20240812215332505 GGD fit 采用 moment-matching 方法(该方法的基础来源于 概率论- 点估计 -矩估计法) 来估计 α 和σ参数, 主要源自 Estimation of Shape Parameter for Generalized Gaussian Distributions in Subband Decompositions of Video 这篇文章的结论 参考自:https://blog.csdn.net/sinat_36438332/article/details/88363492 零均值的广义高斯分布:(原文献中, α 用γ替代) is the gamma function 首先 σ 是标准差,可以通过 下列公式得到: 右侧的公式可以计算得到 α 是间接求解得到的 首先有以下结论: 左侧的公式可以计算得到 !!!!!!! important : ρ , α , σ 随后就是已知 求解α 利用查找匹配的方法确定 α。具体过程如下： 1）给出候选的α ：设定α 的查找区间，如[0.2:0.001:10]即α 在(0.2,10)区间范围每隔0.001取值。 2）将所有α 代入式(4)右边计算ρ ( α ) 3）计算所有ρ ( α ) 与步骤3得出估计值的距离，选取距离最小对应的α 即为所求。 AGGD fit 《MULTISCALE SKEWED HEAVY TAILED MODEL FOR TEXTURE ANALYSIS》 参考资料:https://blog.51cto.com/u_15082391/4077039 AGGD formula: where 首先估计σ 计算 v 定义几个变量 γ :(可求) k-order moment + k-order absolute moment: r ρ 由r的公式得到: ρ和 v 的关系 同样的方法就可求出v example image-20240813010103349 SVM classifier 算法评价 ref https://blog.csdn.net/weixin_45682889/article/details/108739906 MSCN削弱了对纹理的强弱关系依赖 ，但本质还是根据纹理进行评价。 最好用同一设备、在同一环境下先测出一组足够清晰的图作为groundtruth，且亮度不能过大。（在实验时发现亮度过大准确率明显降低。） 该算法仅采用空间域的特征，有一定局限性。比如严格按照patch的分割方式获得一系列patch，如果将不同patch在空间上的位置进行对调，这样每一个patch都还能符合该算法的要求，但是很显然那是个马赛克状的退化图像。","categories":[{"name":"imageprocess","slug":"imageprocess","permalink":"https://epichide.github.io/categories/imageprocess/"}],"tags":[]},{"title":"NIQUE","slug":"ILNIQUE","date":"2024-08-10T08:35:22.000Z","updated":"2024-08-17T13:24:01.108Z","comments":true,"path":"2024/08/10/ILNIQUE/","permalink":"https://epichide.github.io/2024/08/10/ILNIQUE/","excerpt":"","text":"109 feature map: image-20240817142408450 image-20240817142419402 image-20240817142425897 image-20240817142432930 image-20240817142439099 image-20240817142447700 image-20240817142454338 image-20240817142500951","categories":[{"name":"imageprocess","slug":"imageprocess","permalink":"https://epichide.github.io/categories/imageprocess/"}],"tags":[]},{"title":"chan vess segmentation","slug":"Chan–Vese-Segmentation","date":"2024-06-10T08:35:20.000Z","updated":"2024-08-11T07:17:08.484Z","comments":true,"path":"2024/06/10/Chan–Vese-Segmentation/","permalink":"https://epichide.github.io/2024/06/10/Chan%E2%80%93Vese-Segmentation/","excerpt":"chan vess segmentation","text":"chan vess segmentation sign illustration f : denote the given grayscale image, f(x),x is point t : iteration t's border matrix, binary bool ?, describe as iteration th 's edge result, is closed curve mask ε : Heaviside regularization,custom params, = 1 x : pixel/position in image,2D φ : level set function, φ(i,j),φi,j : φ value at point(i,j) C : an edge set curve image Boundary C represented as the zero level set of implicit function φ(x, y)1 H : Heaviside function, for caculate energy function Hε(t,p) : regularised heavyside function, is matrix , size same to image,∈[0,1] for example: if border mark 1, unkown area mark 0, that trans to 1 and 0.5 operator illustration: : sum for all H matrix value —— np.sum(H), is a scale value cinner couter : the optimal values c1 and c2 u : piecewise-smooth function The third and fourth terms penalize discrepancy between the piecewise constant model u and the input image f. divergence 散度计算: 12345def div(fx,fy):# 图像的散度对某幅图像连续求2次梯度得到的zx_x和zy_y的和是等于散度的。换句话说div(z) = zx_x +zy_yd Fyy,fyx=np.grad(fy) Fxy,fxx=np.grad(fx) return fxx+fyy discretize the curvature 曲率计算 : 1234567 def curvature(f): fy,fx=grad(f) Norm=np.sqrt(fx**2+fy**2) Nx=fx/(Norm+1e-8) Ny=fy/(Norm+1e-8) return div(Nx,Ny) img ∇x+ denotes forward diﬀerence in the x dimension : f(x+1)-f(x) ∇x− denotes backward diﬀerence : f(x)-f(x-1) ∇x0 =(∇x+ + ∇x−)/2 is central diﬀerence : (f(x+1)-f(x-1))/2 process step φ update function: φ value at point(i,j) φi,j length penalty μ =0.2, area penalty ν = 0, time step dt = 0.5, convergence tolerance tol = 10e−3 algorithm image-20220411145745250 Reference Deep Learning of Unified Region, Edge, and Contour Models for Automated Image Segmentation↩︎","categories":[{"name":"imageProcess","slug":"imageProcess","permalink":"https://epichide.github.io/categories/imageProcess/"}],"tags":[{"name":"levelset","slug":"levelset","permalink":"https://epichide.github.io/tags/levelset/"},{"name":"segmentation","slug":"segmentation","permalink":"https://epichide.github.io/tags/segmentation/"},{"name":"algotithm","slug":"algotithm","permalink":"https://epichide.github.io/tags/algotithm/"}]},{"title":"HEXO typora github blog 博客搭建","slug":"blog-github","date":"2024-06-10T08:35:20.000Z","updated":"2024-08-11T13:40:22.972Z","comments":true,"path":"2024/06/10/blog-github/","permalink":"https://epichide.github.io/2024/06/10/blog-github/","excerpt":"介绍hexo 的基本生成部署操作和typora的文件如何更新到博客","text":"介绍hexo 的基本生成部署操作和typora的文件如何更新到博客 Hexo 基本操作 我们定义根目录是含有主题、 source等信息的根目录，如下是根目录内的文件 image-20240811020929586 首先是要先把新建的仓库clone到本地，新建博客源码分支，初始化hexo，具体命令如下： 12345678910111213141516$ git clone xxxxxx // xxxxx是github上复制的clone地址$ cd xxxxxx // clone到本地会生成一个跟仓库同名的目录$ git checkout -b hexo // 创建并切换到hexo分支$ hexo init hexo // 初始化hexo，第一个hexo是cmd，第二个hexo是新建hexo目录$ cd hexo // 进入新建的hexo目录$ npm install // 安装相关依赖$ hexo g // generate，生成静态网站$ hexo s // server，本地预览12345678910111213141516 到这里就可以打开浏览器输入localhost:4000，进行本地预览了。 站点文件配置 还需要修改Hexo的配置文件_config.yml，注意此文件应位于hexo目录下，称为站点配置文件。在themes/主题名路径下也有一个_config.yml，称之为主题配置文件。在站点配置文件同级目录下，你可以添加多个主题 添加主题 比如添加next主题： 1234$ cd hexo //确保当前目录处于站点配置目录下// clone NexT主题，如果使用https clone报错，可以自行替换为ssh的链接$ git clone https://github.com/theme-next/hexo-theme-next themes/next 执行如下命令本地验证主题是否生效： 1234$ hexo clean // 清理之前生成的资源$ hexo g // 重新生成$ hexo s // 启动本地服务123 打开浏览器输入localhost:4000，进行本地预览。 image-20240811021553913 部署deploy到github 首先需要安装插件hexo-deployer-git 12$ npm install hexo-deployer-git --save 修改站点配置文件，搜索deploy 123456789101112# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: git repo: # 需要替换为自己仓库的链接，根据https或ssh方式不同自由选择，我已经上传了公钥，所以选择ssh # 如果你配置了多用户ssh，可考虑更改 github.com 为你设置的histname， # 比如 github: git@github_aaa:treeknows/treeknows.github.io.git github: git@github.com:treeknows/treeknows.github.io.git # 此处似乎只能选择master，配置为main时，实际还是会部署到master分支 branch: master123456789 可以将配置修改为如上，记得替换自己的仓库链接。此外配置branch时，设置为main实测是无效的，依旧会push到master分支，如果没有master分支，则会自己创建。这也是为什么在前面推荐修改默认创建分支为master，来自强迫症患者的倔强。 多个GitHub账号配置和多个Hexo博客地址配置 如果你使用 多个GitHub账号配置和多个Hexo博客地址配置， 则需要做一些操作 删除全局配置 123git config --global --unset 'user.name'git config --global --unset 'user.email' 设置local配置 在自己的每个文件夹(repo仓库)下,打开Git Bash,然后进行设置。 12git config user.name `xxx`git config user.email `xxx@xxx.com` 部署到Github 修改配置后，需要手动部署到Github 1hexo g -d 部署成功后，稍待片刻，便可访问GitHub上自己的博客查看效果了。 问题 问题1： You have to configure the deployment settings in _config.yml first! image-20240811023454559 原因：yml格式不对 冒号后面唯一空格，是repo 不是github image-20240811023624065 问题2 fatal: unable to auto-detect email address https://blog.csdn.net/nineya_com/article/details/103301870 在这里插入图片描述 2.进入我们博客目录的“.deploy_git.git”子目录，找到config文件。 3.打开config文件，添加以下内容 1234[user] email=你的邮箱 name=GitHub用户名 再次运行 1hexo g -d 问题3：blog 404 github创建个人网页登录后404无法显示的问题 https://blog.csdn.net/weixin_43658047/article/details/133742886 image-20240811031004276 1.首先必须要有内容，默认是会找index.html文件，找不到该文件会找readme.md文件，也就是说最简单的方法是，创建了与用户名同名的repository后username.github.io后，添加一个readme.md文件，得在readme里打点字，这个里面得有东西 2.另外在username.github.io这个repository的setting/github page中这个选择Deploy from a branch，注意将仓库里里的main分支改为master，同时在下图页面，将底下默认的main改成master，就能访问了 image-20240811031048976 typora更新至blog generate md 和image存放结构 在 讨论图片如何设置前，我们需要先知道 hexo g 的时候图片和md文件会如何放置 在_config.yml文件里有一个参数 post_asset_folder , 它有两个作用： 如果为true， 会在使用 hexe new blogname 时候，在创建 md文件同时 ，还创建一个同名文件夹 123_posts [blogname.md] [blogname] 同时还需要安装一个插件 hexo-asset-image 1npm install https://github.com/CodeFalling/hexo-asset-image --save 即post_asset_folder 激活 和 hexo-asset-image 插件安装好情况下，在generate的时候， 除了 在imgs在存放 img ，还在 blog里存放img image-20240811123640730 如果为false，只在source/imgs在存放 img image-20240811123744791 总结路径关系： source/posts里 的 md → public/yy/mm/dd/blogname/index.html source/imgs/blogname里 的 image → public/imgs/blogname/image source/posts/blogname里 的 image → public/yy/mm/dd/blogname/images(只在post_asset_folder 为true + 安装hexo-asset-image时 产生 ) image-20240811051938209 typora图片路径 根据是否激活post_asset_folder，其路径配置也不太一样， 目前 只有激活的的没有问题，没有激活的html的图片显示还是有些问题没有解决 post_asset_folder 为 true 我们先观察blog取的图片路径，以next主题为例（其他主题可能有差异，不能确定是否适用），需要显示图片的主要有两个地方：1. home 预览页即主页 2. 完整博客内容页 切换 post_asset_folder 后，注意要使用hexo clean 一下 post_asset_folder 为 true+ 安装hexo-asset-image，预览和博客的图片根路径都是 public/yy/mm/dd： image-20240811130130376 post_asset_folder 为 false+ 安装hexo-asset-image，预览的路径public 博客路径public/yy/mm/dd/blogname ，使用的路径是不同的，因而需要存放多次，可能存在预览和博客内容不一致的情况： image-20240811130511497 那么在上传新的博客的时候，只要在_posts 存放 md 文件和同名文件即可，md 按照blogname/image的形式获取即可 123_posts [blogname.md] [blogname] typora 图片拷贝文件位置就可以这样设置./$(filename) image-20240811132309452 post_asset_folder 为 false 没整明白。。。。。。 对于hexo 图片的路径和博客是分开的，图片从根目录开始为 imgs/标题名/xxxpng ，比如下面这个是一个能够正常获取的图片路径 imgs\\blogname\\xxx.png image-20240811052444531 因此typora的图片插入路径需要与之保持统一，即路径名一致 imgs\\blogname\\xxx.png typora img path 我们只要确保md能够通过这一路径访问并显示图片，那么我们就能实现typora和网页端都能正常显示图片了，typora 显示这种路径规则的图片有多种方式： 最简单的，把图像存在imgs中 在preference中设置图片的copy路径 ，imgs/$filename 在md 文件中 用 imgs\\blogname\\xxx.png 获取图片 多种组合实现：举个例子： 在preference中设置图片的copy路径 ，比如 ../imgs/$filename 在format - image - use image root path 设置 .. 上一级目录为图片根目录 image-20240811055105205 在md 文件中 用 imgs\\blogname\\xxx.png 获取图片 1+2部其实就消除了 .. md文件 head 12345678---title: 测试文章date: 2021-06-10 16:35:20tags:- 原创categories:- Java--- 将&lt;!-- more --&gt;插入到文章后，主页在插入处截止了预览，出现的阅读全文的按钮。 问题： 路径错误/.com// hexo图片显示不出且图片路径错误/.com// https://blog.csdn.net/sluck_0430/article/details/136431303 卸载 hexo-asset-image 插件：npm uninstall hexo-asset-image 即可 公式渲染 首先，在NexT主题配置文件中将mathjax设为渲染引擎 1234math: ... mathjax: enable: true mathjax 和 katex 是互斥的两个选项，enable 不能同时 true或 false。 如果设置 mathjax : true ，就需要更换渲染引擎， hexo-renderer-pandoc 或 hexo-renderer-kramed。 如果 katex : true ，则需要更换 hexo-renderer-markdown-it ，或者在原来的 hexo-renderer-marked 引擎下使用 markdown-it-katex plugin。 安装插件 12npm uninstall hexo-renderer-marked --savenpm npm install hexo-renderer-pandoc --save md head添加mathjax 123title: xxx......mathjax: true 重新生成和启动本地服务器 hexo clean &amp;&amp; hexo s 就可以显示公式了，像这样 主题 ==TODO== REFERENCE REF： Github Pages + Hexo框架 + NexT主题搭建个人博客：https://blog.csdn.net/Darlinnn/article/details/130279000 Git 多个GitHub账号配置和多个Hexo博客地址配置：https://blog.csdn.net/Tmraz/article/details/107400453#5__55 GitHub Pages + Hexo搭建个人博客网站，史上最全教程：https://blog.csdn.net/yaorongke/article/details/119089190 【Hexo】GitHub+Typora写博客+图片上传:https://blog.csdn.net/Qxiaofei_/article/details/124629908 Hexo Next主题渲染 Latex 公式的配置方法","categories":[{"name":"web","slug":"web","permalink":"https://epichide.github.io/categories/web/"}],"tags":[{"name":"github","slug":"github","permalink":"https://epichide.github.io/tags/github/"},{"name":"typora","slug":"typora","permalink":"https://epichide.github.io/tags/typora/"},{"name":"hexo","slug":"hexo","permalink":"https://epichide.github.io/tags/hexo/"}]},{"title":"Hexo 富文本","slug":"use-note-block","date":"2024-06-10T08:35:20.000Z","updated":"2024-08-11T16:52:24.583Z","comments":true,"path":"2024/06/10/use-note-block/","permalink":"https://epichide.github.io/2024/06/10/use-note-block/","excerpt":"","text":"在 Hexo 中使用 NOTE 提示块 123456789101112131415161718192021222324&#123;% note default %&#125;一个 default 提示&#123;% endnote %&#125;&#123;% note primary %&#125;一个 primary 提示&#123;% endnote %&#125;&#123;% note success %&#125;一个 success 提示&#123;% endnote %&#125;&#123;% note info %&#125;一个 info 提示&#123;% endnote %&#125;&#123;% note warning %&#125;一个 warning 提示&#123;% endnote %&#125;&#123;% note danger %&#125;一个 danger 提示&#123;% endnote %&#125; 一个 default 提示 一个 primary 提示 一个 success 提示 一个 info 提示 一个 warning 提示 一个 danger 提示 使用 Tabs 标签 123456789101112&#123;% tabs 标签, 1 %&#125; &lt;!-- tab --&gt;**选项卡 1** &lt;!-- endtab --&gt;&lt;!-- tab --&gt;**选项卡 2**&lt;!-- endtab --&gt;&lt;!-- tab 标签三 --&gt;**选项卡 3** , 名字为 `TAB三`&lt;!-- endtab --&gt;&#123;% endtabs %&#125; 标签 1标签 2标签三选项卡 1选项卡 2选项卡 3 , 名字为 TAB三","categories":[{"name":"web","slug":"web","permalink":"https://epichide.github.io/categories/web/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://epichide.github.io/tags/hexo/"},{"name":"markdown","slug":"markdown","permalink":"https://epichide.github.io/tags/markdown/"}]},{"title":"配置 SSH 管理多个 Git 仓库和以及多个 Github 账号","slug":"ssh-github","date":"2024-06-10T08:35:20.000Z","updated":"2024-08-11T08:28:34.764Z","comments":true,"path":"2024/06/10/ssh-github/","permalink":"https://epichide.github.io/2024/06/10/ssh-github/","excerpt":"基本介绍 使用场景 假如你拥有多个github账户，那么在编辑和push 仓库的时候需要指定特定用户进行登录，对于github仓库管理是通过ssh与github进行通讯的，那么就需要管理不同的账户下的SSH配置，即SSH公钥和 私钥。","text":"基本介绍 使用场景 假如你拥有多个github账户，那么在编辑和push 仓库的时候需要指定特定用户进行登录，对于github仓库管理是通过ssh与github进行通讯的，那么就需要管理不同的账户下的SSH配置，即SSH公钥和 私钥。 SSH 如果我们要使用 Github 这种 git 代码托管平台的话，首先本地要生成一个 SSH 私钥(如id_rsa) 和 公钥(如id_rsa.pub)，然后将 公钥 填写到 Github 的 SSH Key 管理面板中。当我们向 Github 推送代码的时候会首先发起身份校验。此时，本地会将用户信息通过 SSH 私钥 执行『签名』操作 本地 - 私钥 - id_rsa github - 公钥 - id_rsa.pub 通过配置各个用户名的公钥和私钥，在使用的时候指定使用对应的私钥即可通过认证，进行通讯和数据传输。举例来说，如果我们要使用 Github 这种 git 代码托管平台的话，首先本地要生成一个 SSH 私钥(如id_rsa) 和 公钥(如id_rsa.pub)，然后将 公钥 填写到 Github 的 SSH Key 管理面板中。当我们向 Github 推送代码的时候会首先发起身份校验。此时，本地会将用户信息通过 SSH 私钥 执行『签名』操作。当签名信息发送到 Github 的时候，Github 就会使用用户保存在平台上的 公钥 来校验签名信息，使用 私钥 签名信息只能由对应的 公钥 进行校验，因此如果 Github 对签名校验通过，就可以认证当前的用户对代码仓库拥有响应的操作权限，之后就可以让用户提交的代码入库了，整体流程如下图： img 使用 SSH公钥/私钥生成 进入到 ssh 目录下，windows一般是：C:【用户名】\\.ssh 假设你的邮箱是 aaa@126.com 生成一对 SSH 密钥 1ssh-keygen -t rsa -C &quot;aaa@126.com&quot; 这个指令的意思是使用 ssh-keygen 生成密钥，-t 参数密钥的加密方式是 rsa，-C 参数可以为密钥指定备注，通常备注可以为你的邮箱，或者你也可以写成你要连接的远程服务器名（总之不重要） 输入完成之后会进入一个交互式终端界面，首先会询问你的密钥文件名称： 1Enter file in which to save the key (/Users/username/.ssh/id_rsa): 我们可以使用回车跳过，那么密钥文件名称就自动生成为 id_加密方式，如 id_rsa。 之后会提示用户输入密码： 1Enter passphrase (empty for no passphrase): 这个密码是用来保护你的私钥的，我们这里避免麻烦可以直接跳过。 完成以后，目录下会产生私钥文件 id_rsa 和公钥文件 id_rsa.pub . 如果你之前和其他网站也配置过 ssh 产生过这些文件，注意先备份一个，因为这个操作会覆盖原来的同名文件。 随后到github 上选择 setting → ssh and GPG keys → new ssh key image-20240811005017813 随后把公钥里的内容粘贴到 key里，title可随意命名 image-20240811005251367 config 文件配置ssh 一般来说如果没有其他指定的配置，在访问的时候会自动使用 id_rsa作为认证私钥，如果单一账户不需要配置，如果你配置了多个ssh，则需要通过config文件配置 假设 你在github 有两个账户 aaa，bbb 对应的私钥 id_rsa 重命名为 aaa_id_rsa 和 bbb_ id_rsa 账户1 ： aaa ， 对应私钥 ： 12345678910111213# github 主账号的配置Host github_aaa User git Hostname github.com PreferredAuthentications publickey IdentityFile ~/.ssh/aaa_id_rsa # github 新账号的配置Host github_bbb User git Hostname github.com PreferredAuthentications publickey IdentityFile ~/.ssh/bbb_ id_rsa 从上面配置文件可以看到 Host别目和公钥是二者的主要区别， user 设定为git是访问GitHub是需要使用的统一用户名，其实写不写都无所谓，ssh 连接主要是通过这里 hostname确定要用哪一个私钥进行认证 config 配置文件中的各项配置意思为： Host：指定连接到的主机名，可以随意指定，相当于实际连接目标主机的别名； User：指定使用的用户名，通常为 git，也可以不指定； Hostname：指定连接到的主机的实际域名或IP地址。如果是向 Github 推送代码，则为 github.com，如果是向公司的 Git 代码托管平台推送代码，则填写公司主机的地址 Port：SSH 服务的端口号，默认为 22，可以不写 PreferredAuthentications：指定优先使用的身份验证方法，指定为publickey，即使用公钥进行身份认证。 IdentityFile：指定要使用的私钥文件路径，即指向你创建的私钥，我们这里分别为不通的 Git 代码托管平台指定了不同的私钥 测试连接 然后我们来测试一下连接： 123ssh -T git@github_aaa# 输出如下内容就说明身份认证通过了！Hi aaa[你小号的用户名]! You&#x27;ve successfully authenticated, but GitHub does not provide shell access. 由于你的代码的仓库源在 Github 上，因此 SSH 连接的主机就是 github.com，github_aaa 对应的实际主机就是github.com， git是默认访问github的用户名， 由于在这里制定了use，因此配置文件里的usr并不起作用。 如果输出的用户名是你的小号，那就说明可以正常在刚才的那个仓库里推送代码了。 拉取仓库 这个时候，你从小号的 Github 中 clone 下来一个仓库，假设地址为 git@github.com:user_x/blog.git，那么就在终端中的host：github.com 改为 github_aaa： 123git clone git@github.com:user_x/blog.gitgit clone git@github_aaa:user_x/blog.git img 提交 #TODO REF： 如何配置 SSH 管理多个 Git 仓库和以及多个 Github 账号","categories":[{"name":"web","slug":"web","permalink":"https://epichide.github.io/categories/web/"}],"tags":[{"name":"github","slug":"github","permalink":"https://epichide.github.io/tags/github/"},{"name":"ssh","slug":"ssh","permalink":"https://epichide.github.io/tags/ssh/"}]}],"categories":[{"name":"though","slug":"though","permalink":"https://epichide.github.io/categories/though/"},{"name":"imageprocess","slug":"imageprocess","permalink":"https://epichide.github.io/categories/imageprocess/"},{"name":"imageProcess","slug":"imageProcess","permalink":"https://epichide.github.io/categories/imageProcess/"},{"name":"web","slug":"web","permalink":"https://epichide.github.io/categories/web/"}],"tags":[{"name":"IQA","slug":"IQA","permalink":"https://epichide.github.io/tags/IQA/"},{"name":"levelset","slug":"levelset","permalink":"https://epichide.github.io/tags/levelset/"},{"name":"segmentation","slug":"segmentation","permalink":"https://epichide.github.io/tags/segmentation/"},{"name":"algotithm","slug":"algotithm","permalink":"https://epichide.github.io/tags/algotithm/"},{"name":"github","slug":"github","permalink":"https://epichide.github.io/tags/github/"},{"name":"typora","slug":"typora","permalink":"https://epichide.github.io/tags/typora/"},{"name":"hexo","slug":"hexo","permalink":"https://epichide.github.io/tags/hexo/"},{"name":"markdown","slug":"markdown","permalink":"https://epichide.github.io/tags/markdown/"},{"name":"ssh","slug":"ssh","permalink":"https://epichide.github.io/tags/ssh/"}]}